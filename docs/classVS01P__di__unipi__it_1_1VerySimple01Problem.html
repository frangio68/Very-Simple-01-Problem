<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="$relpathstylesheet.css.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceVS01P__di__unipi__it.html">VS01P_di_unipi_it</a>      </li>
      <li class="navelem"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html">VerySimple01Problem</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">VerySimple01Problem Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class solves the Very Simple Problem in 0/1 optimization (VS01P): given n 0/1 variables x[ i ] and n weights w[ i ], i = 0 ...  
 <a href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#details">More...</a></p>

<p><code>#include &lt;VrySmplP.h&gt;</code></p>

<p><a href="classVS01P__di__unipi__it_1_1VerySimple01Problem-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Types</div></td></tr>
<tr class="memitem:a5b53e5716aeadbb040a52c9c8c124c74"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a></td></tr>
<tr class="memdesc:a5b53e5716aeadbb040a52c9c8c124c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the weights w[ i ].  <a href="#a5b53e5716aeadbb040a52c9c8c124c74"></a><br/></td></tr>
<tr class="memitem:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a></td></tr>
<tr class="memdesc:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the indices "i" in "w[ i ]", "x[ i ]".  <a href="#ad53d6229d7ec28555a9c9c2fd9abf773"></a><br/></td></tr>
<tr class="memitem:a24c046a3e80e6ae59e1f532259c68983"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a24c046a3e80e6ae59e1f532259c68983">ZeroOne</a></td></tr>
<tr class="memdesc:a24c046a3e80e6ae59e1f532259c68983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the variables x[ i ]: must be large enough to hold both values 0 and 1 (is there any type which can not?).  <a href="#a24c046a3e80e6ae59e1f532259c68983"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor</div></td></tr>
<tr class="memitem:a6ad04978c3496a74019f3e93a5bbd7a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a6ad04978c3496a74019f3e93a5bbd7a1">VerySimple01Problem</a> (<a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> n)</td></tr>
<tr class="memdesc:a6ad04978c3496a74019f3e93a5bbd7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="#a6ad04978c3496a74019f3e93a5bbd7a1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Other initializations</div></td></tr>
<tr class="memitem:a0cbc8842b1f062bf31aa48400f541c3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a0cbc8842b1f062bf31aa48400f541c3d">SetWeights</a> (const <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> *wght)</td></tr>
<tr class="memdesc:a0cbc8842b1f062bf31aa48400f541c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new vector of weights, effectively changing all the data of the VS01P.  <a href="#a0cbc8842b1f062bf31aa48400f541c3d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Solving the problem</div></td></tr>
<tr class="memitem:a5805f1f4ab4404a09a06be25c3475213"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a5805f1f4ab4404a09a06be25c3475213">SolveVS01P</a> (void)</td></tr>
<tr class="memdesc:a5805f1f4ab4404a09a06be25c3475213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the problem (not a big deal).  <a href="#a5805f1f4ab4404a09a06be25c3475213"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading the solution(s)</div></td></tr>
<tr class="memitem:a55b2657244a60c7ca86eb31dd978703c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a55b2657244a60c7ca86eb31dd978703c">GetVal</a> (void)</td></tr>
<tr class="memdesc:a55b2657244a60c7ca86eb31dd978703c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the objective function value of the next best solution.  <a href="#a55b2657244a60c7ca86eb31dd978703c"></a><br/></td></tr>
<tr class="memitem:adc653457bc76d1fe9cb5f452c3175d46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#adc653457bc76d1fe9cb5f452c3175d46">GetSol</a> (<a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a24c046a3e80e6ae59e1f532259c68983">ZeroOne</a> *x)</td></tr>
<tr class="memdesc:adc653457bc76d1fe9cb5f452c3175d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next best solution.  <a href="#adc653457bc76d1fe9cb5f452c3175d46"></a><br/></td></tr>
<tr class="memitem:ac0a57e6e93c1009d94919dafd018340c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#ac0a57e6e93c1009d94919dafd018340c">NSol</a> (void) const </td></tr>
<tr class="memdesc:ac0a57e6e93c1009d94919dafd018340c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of solutions enumerated so far.  <a href="#ac0a57e6e93c1009d94919dafd018340c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading the data of the problem</div></td></tr>
<tr class="memitem:ad89b72d9de630ee6a5c1ab749e0ec998"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad89b72d9de630ee6a5c1ab749e0ec998"></a>
<a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Getn</b> (void) const </td></tr>
<tr class="memitem:adef4ca490a1db8ab9309ccf398195d1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adef4ca490a1db8ab9309ccf398195d1e"></a>
const <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Getw</b> (void) const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a2534095d6c818898636af0b6c12ff6ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a2534095d6c818898636af0b6c12ff6ce">~VerySimple01Problem</a> ()</td></tr>
<tr class="memdesc:a2534095d6c818898636af0b6c12ff6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the class.  <a href="#a2534095d6c818898636af0b6c12ff6ce"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class solves the Very Simple Problem in 0/1 optimization (VS01P): given n 0/1 variables x[ i ] and n weights w[ i ], i = 0 ... </p>
<p>n - 1, the problem is </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \max \{ \sum_{i = 0}^{n - 1} w[ i ] x[ i ] : x[ i ] \in \{ 0 , 1 \} \hspace{1cm} , i = 0 , ... , n - 1 \} \]" src="form_0.png"/>
</p>
<p> The problem is so exceedingly trivial to solve (scan the variables in any order, assign 1 to the variable if the weight is &gt; 0, assign 0 if the weight is &lt; 0, do whatever if the weight is zero) that one may well argue against the need of a class for doing that. However, this class does more than solving the problem: it can efficiently produce all the solutions of the problem (the 2^n different strings of n bits) ordered by non increasing objective function value.</p>
<p>Of course, enumerating all these solutions can never be done efficiently since they are exponentially many. However, we are able to generate them one by one, and the effort to generate each new solution is very limited: generating the (k+1)-th solution only requires O(n) -- the bare minimum necessary to write it down. Also, only O(k) memory is required to generate k solutions (not counting the memory required to store the solution themselves, though).</p>
<p>This is obtained by iteratively constructing and visiting an enumeration tree, whose structure is somewhat different from those used e.g. in enumeration algorithms. The root of the tree is (one of) the optimal solution(s) of the problem, say x^*. Each node of the enumeration tree (not only the leaf nodes, as usual in enumeration trees) contains a solution of the problem. The sons of the root (imagine them pictured from left to right) are as follows:</p>
<ul>
<li>the first node is obtained by flipping variable x[ 0 ] (giving it the different value with respect to x^*[ 0 ]) and solving the VS01P on all the other variables considering that that variable is fixed, i.e., keeping all the other variables as they are in x^*;</li>
</ul>
<ul>
<li>the second node is obtained by keeping x[ 0 ] as in x^*, flipping x[ 1 ] and solving the VS01P on all the other variables considering the first two variables as fixed, i.e., keeping all the other variables as they are in x^*;</li>
</ul>
<ul>
<li>...</li>
</ul>
<ul>
<li>the n-th node is obtained by fixing all the first n - 1 variables as they are in x^* and flipping x[ n - 1 ].</li>
</ul>
<p>The tree is then constructed by recursively iterating the process on all the sons. In each node, the first k variables are fixed (x[ k - 1 ] is the one that is flipped with respect to the father node). Then, the sons of that node are obtained, for i = k ... n - 1, by keeping x[ 0 ] ... x[ i - 1 ] as in the father node, flipping x[ i ] w.r.t. the father node (and, therefore, w.r.t. x^*) and solving the VS01P on all the other variables considering the first i + 1 variables as fixed, i.e., keeping all the other variables as they are in x^*.</p>
<p>This tree is exponential in size (of course). However, if the variables are properly ordered it is possible to only explicitly construct and visit O(k) nodes of the tree to enumerate the first k solutions (in nonincreasing order of the objective function value) of VS01P. The good order of the variables is that for nondecreasing value of | w[ i ] |; with this order, flipping a variable i produces "less damage" (decreases less the objective function value) than flipping a variable j with j &gt; i.</p>
<p>If the variables are ordered this way, then the solutions of the problem can be listed, in the desired order, as follows. The set of unvisited nodes of the tree from which the exploration must proceed, Q, is initialized with the root (containing the optimal solution x^*). Each time the next best solution is required, the best node (the one with largest objective function value of the associated solution) is extracted from Q and the associated solution is returned. Then, the first son of that node is added to Q. Also, if the node has a father (it is not the root) it surely is the rightmost son of his father inserted in Q as yet; then, its brother next to the right (if any) is also added to Q. No other nodes need to be added to Q, since all other sons, and all other brothers more to the right w.r.t. the immedaite one, surely contain solutions with worse (not better) objective function value w.r.t. the two generated ones.</p>
<p>This exploration strategy ensures that producing the k best solutions to the problem requires generating, and inserting in Q, at most 2k nodes of the enumeration tree. Since each node of can be represented with O(1) memory, the storage required to hold the representation of the fragment of the tree generated so far is O(k). Also, generating the (k + 1)-th solution requires O( lg k ) for searching the best node in Q (using e.g. a binary heap), O(1) for generating the corresponding two new nodes and O(n) to write down the solution using the information stored in the current fragment of the tree (climbing the tree from the node to the root gives the list of all and only variables than need to be flipped w.r.t. x^*, and those variables are even ordered). Since k is no more than 2^n, the overall complexity of generating a new solution is O(n). </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a5b53e5716aeadbb040a52c9c8c124c74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of the weights w[ i ]. </p>
<p>By changing this definition and recompiling the code works with whatever base type is chosen. It may have been set as a template, but it seemed overkill. </p>

</div>
</div>
<a class="anchor" id="ad53d6229d7ec28555a9c9c2fd9abf773"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of the indices "i" in "w[ i ]", "x[ i ]". </p>
<p>By changing this definition and recompiling the code works with whatever base type is chosen. It may have been set as a template, but it seemed overkill. </p>

</div>
</div>
<a class="anchor" id="a24c046a3e80e6ae59e1f532259c68983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a24c046a3e80e6ae59e1f532259c68983">ZeroOne</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of the variables x[ i ]: must be large enough to hold both values 0 and 1 (is there any type which can not?). </p>
<p>By changing this definition and recompiling the code works with whatever base type is chosen. It may have been set as a template, but it seemed overkill. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6ad04978c3496a74019f3e93a5bbd7a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html">VerySimple01Problem</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor of the class. </p>
<p>The parameter "n" is the number of variables in the VS01P. </p>

</div>
</div>
<a class="anchor" id="a2534095d6c818898636af0b6c12ff6ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html">VerySimple01Problem</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor of the class. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0cbc8842b1f062bf31aa48400f541c3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a0cbc8842b1f062bf31aa48400f541c3d">SetWeights</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> *&#160;</td>
          <td class="paramname"><em>wght</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new vector of weights, effectively changing all the data of the VS01P. </p>
<p>The new weights are expected to be found in the first n positions of the vector wght. The class has the right to retain a pointer to this vector and keep using it until <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a0cbc8842b1f062bf31aa48400f541c3d" title="Set a new vector of weights, effectively changing all the data of the VS01P.">SetWeights()</a> is called again, so the caller must not change or delete the vector until it is in use by the class. Calling again <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a0cbc8842b1f062bf31aa48400f541c3d" title="Set a new vector of weights, effectively changing all the data of the VS01P.">SetWeights()</a> destroys any existing information about the previous set of k-optimal solutions, restarting the generating process anew.</p>
<p>The class does not change the vector wght (the pointer is read-only).</p>
<p>This method has to be called at least once if any method in the following sections is to be called. </p>

</div>
</div>
<a class="anchor" id="a5805f1f4ab4404a09a06be25c3475213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a5805f1f4ab4404a09a06be25c3475213">SolveVS01P</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the problem (not a big deal). </p>
<p>This also re-initialize the process for generating the solutions, so the next solution obtained with <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#adc653457bc76d1fe9cb5f452c3175d46" title="Get the next best solution.">GetSol()</a> [see below] after a call to <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a5805f1f4ab4404a09a06be25c3475213" title="Solves the problem (not a big deal).">SolveVS01P()</a> will always be (one of) the optimal one(s).</p>
<p>This method has to be called at least once every time the weights change [see <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a0cbc8842b1f062bf31aa48400f541c3d" title="Set a new vector of weights, effectively changing all the data of the VS01P.">SetWeights()</a> above] is any solution for the corresponding VS01P is desired. </p>

</div>
</div>
<a class="anchor" id="a55b2657244a60c7ca86eb31dd978703c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a55b2657244a60c7ca86eb31dd978703c">GetVal</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the objective function value of the next best solution. </p>
<p>This method can be called only after <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a5805f1f4ab4404a09a06be25c3475213" title="Solves the problem (not a big deal).">SolveVS01P()</a> [see above]. At the first call it returns the optimal objective function value of VS01P. At the subsequent calls it starts returning the objective function values of all the solutions to VS01P, in nonincreasing order. If more than one solution have the same value of the objective function, that value will be returned as many times as there are solutions.</p>
<dl class="section note"><dt>Note:</dt><dd>This method must not be called more than 2^n times, as there are "only" that many different solutions. </dd></dl>

</div>
</div>
<a class="anchor" id="adc653457bc76d1fe9cb5f452c3175d46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#adc653457bc76d1fe9cb5f452c3175d46">GetSol</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a24c046a3e80e6ae59e1f532259c68983">ZeroOne</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the next best solution. </p>
<p>This method and be called only after <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a55b2657244a60c7ca86eb31dd978703c" title="Get the objective function value of the next best solution.">GetVal()</a> [see above]. It returns the solution having the value of the objective function returned by the latest call to <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a55b2657244a60c7ca86eb31dd978703c" title="Get the objective function value of the next best solution.">GetVal()</a>. The solution is written in the first n positions of the vector x.</p>
<p>Note that the "pointer in the list of the solutions" is only "moved" by calls to <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a55b2657244a60c7ca86eb31dd978703c" title="Get the objective function value of the next best solution.">GetVal()</a>. That is, two subsequent calls to <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#adc653457bc76d1fe9cb5f452c3175d46" title="Get the next best solution.">GetSol()</a> with no calls to <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a55b2657244a60c7ca86eb31dd978703c" title="Get the objective function value of the next best solution.">GetVal()</a> in between will return the same solution. Analogously, calling k times <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a55b2657244a60c7ca86eb31dd978703c" title="Get the objective function value of the next best solution.">GetVal()</a> with no calls to <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#adc653457bc76d1fe9cb5f452c3175d46" title="Get the next best solution.">GetSol()</a> in between amounts to discarding k - 1 solutions, since only the solution corresponding to the last return value of <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#a55b2657244a60c7ca86eb31dd978703c" title="Get the objective function value of the next best solution.">GetVal()</a> can then be retrieved. </p>

</div>
</div>
<a class="anchor" id="ac0a57e6e93c1009d94919dafd018340c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#ad53d6229d7ec28555a9c9c2fd9abf773">VerySimple01Problem::Index</a> <a class="el" href="classVS01P__di__unipi__it_1_1VerySimple01Problem.html#ac0a57e6e93c1009d94919dafd018340c">NSol</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of solutions enumerated so far. </p>

</div>
</div>
</div><!-- contents -->
</body>
</html>
